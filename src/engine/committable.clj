;; copyright (c) 2015 Sean Corfield

(ns engine.committable
  "Committable protocol for output data sources.
  Also commit! implementation for update! or insert!
  selection, based on primary key in the row."
  (:require [engine.input :as i]))

(defprotocol Committable
  "An output data source is committable. You can delete! (by key),
  insert! new data (rows), and update! existing data (rows by key),
  and it knows how to get the primary key for any given table."
  (delete! [this table pk v])
  (insert! [this table row])
  (update! [this table row pk v])
  (key-generator [this table])
  (primary-key [this table]))

(defn lookup-keys
  "For any row fields that are keywords, look up their value
  in the environment. This allows updates to refer to keys
  generated by earlier updates in the list."
  [row env]
  (reduce-kv (fn [row k v] (assoc row k (if (keyword? v) (v env) v)))
             {} row))

(defn commit!
  "Commit all of the given updates to the supplied data sources.
  Applies the updates in order, building the key lookup environment
  as it goes, and replacing key references (columns with keyword values).
  Although we generally assume tables, and rows, the table is really
  just an arbitrary key into the data store and the row could be any
  type of value. If the row is not a map, we only ever do insert!
  If primary-key returns a non-nil value, we assume key generation
  is in effect and will attempt to lookup foreign keys in the
  environment, based on any previously seen keys for updates."
  [data-sources updates]
  (reduce (fn [env [key dsn table row pk key-gen delete-key]]
            (let [ds (i/get-dsn data-sources dsn)
                  pk (or pk (primary-key ds table))
                  key-gen (or key-gen (key-generator ds table) identity)]
              (if delete-key
                (do
                  (delete! ds table pk delete-key)
                  env)
                (if-let [pkv (and pk (map? row) (get row pk))]
                  (do
                    (update! ds table (lookup-keys (dissoc row pk) env) pk pkv)
                    (cond-> env key (assoc key pkv)))
                  (let [new-row (key-gen row)
                        new-pk (insert! ds table (cond-> new-row
                                                         pk (lookup-keys env)))]
                    (cond-> env key (assoc key new-pk)))))))
          {}
          updates))
